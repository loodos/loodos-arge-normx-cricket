"""
Auto-generated discrepancy detection script for {{ project_id }}
Run with: python main.py --start-date 2025-01-01 --end-date 2025-01-31 --cdn-url ... --cdn-bucket ...
"""
import argparse
import sys
import json
from datetime import datetime, timezone
from typing import Dict, Any, Optional

import boto3
import httpx
from botocore.config import Config as BotoConfig

from utils.data_loader import DataLoader
from logic.processor import DiscrepancyProcessor
from config import settings


def get_access_token(
    login_url: str,
    email: str,
    password: str,
    timeout: float = 30.0,
) -> str:
    """
    Authenticate with the login endpoint and get an access token.
    
    Args:
        login_url: The login endpoint URL
        email: User email for authentication
        password: User password for authentication
        timeout: Request timeout in seconds
        
    Returns:
        The access token string
        
    Raises:
        ValueError: If login fails or token is not found in response
    """
    print(f"Authenticating with login endpoint: {login_url}")
    
    try:
        with httpx.Client(timeout=timeout) as client:
            response = client.post(
                login_url,
                json={
                    "email": email,
                    "password": password,
                },
                headers={"Content-Type": "application/json"},
            )
            response.raise_for_status()
            
            data = response.json()
            
            # Try common token field names
            access_token = data["payload"]["accessToken"]
            
            if not access_token:
                raise ValueError(f"Access token not found in login response. Keys: {list(data.keys())}")
            
            print("Successfully obtained access token")
            return access_token
            
    except httpx.HTTPError as e:
        raise ValueError(f"Login request failed: {e}")
    except Exception as e:
        raise ValueError(f"Failed to get access token: {e}")


def load_data(start_date: str, end_date: str, timeout: float) -> Any:
    """
    Load data from the configured data source.
    """
    source_type = settings.DATA_SOURCE_TYPE

    if source_type == "sql":
        print(f"Loading data from SQL database...")
        return DataLoader.from_sql(
            settings.CONNECTION_STRING,
            start_date=start_date,
            end_date=end_date,
            timeout=timeout,
        )
    elif source_type == "api":
        print(f"Loading data from API: {settings.API_URL}")
        
        # Get auth token - either from static config or via login
        auth_token = getattr(settings, "AUTH_TOKEN", None)
        
        # If no static token, try to get one via login
        auth_token = get_access_token(
            login_url=settings.LOGIN_URL,
            email=settings.LOGIN_EMAIL,
            password=settings.LOGIN_PASSWORD,
            timeout=timeout,
        )

        return DataLoader.from_api(
            start_date=start_date,
            end_date=end_date,
            api_url=settings.API_URL,
            auth_token=auth_token,
            page_size=settings.API_PAGE_SIZE,
            timeout=timeout,
        )
    else:
        raise ValueError(
            f"Unsupported data source type: {source_type}. "
            "Supported types: 'sql', 'api'"
        )


def upload_to_cdn(
    report: Dict[str, Any],
    cdn_url: str,
    access_key: str,
    secret_key: str,
    bucket_name: str,
    enable_ssl: bool = True,
) -> Optional[str]:
    """
    Upload the discrepancy report to CDN using boto3.
    
    Args:
        report: The discrepancy report to upload
        cdn_url: S3-compatible endpoint URL
        access_key: Access key for authentication
        secret_key: Secret key for authentication
        bucket_name: Name of the bucket
        enable_ssl: Whether to use SSL
        
    Returns:
        The file path (object key) on CDN, or None if upload failed
    """
    if not all([cdn_url, access_key, secret_key, bucket_name]):
        print("Warning: CDN configuration incomplete. Skipping upload.")
        return None
    
    # Generate file key: /normx/report/project_id_timestamp.json
    project_id = report.get("project_id", "unknown")
    timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
    object_key = f"normx/report/{project_id}_{timestamp}.json"
    
    print(f"Uploading report to CDN: {bucket_name}/{object_key}")
    
    try:
        # Configure boto3 client for S3-compatible storage
        s3_client = boto3.client(
            "s3",
            endpoint_url=f"{'https' if enable_ssl else 'http'}://{cdn_url}",
            aws_access_key_id=access_key,
            aws_secret_access_key=secret_key,
            config=BotoConfig(
                signature_version="s3v4",
                s3={"addressing_style": "path"},
            ),
            region_name="auto"
        )
        
        # Convert report to JSON
        report_json = json.dumps(report, indent=2, default=str)
        
        # Upload to S3-compatible storage
        s3_client.put_object(
            Bucket=bucket_name,
            Key=object_key,
            Body=report_json.encode("utf-8"),
            ContentType="application/json",
        )
        
        print(f"Report uploaded successfully: {object_key}")
        return object_key
        
    except Exception as e:
        print(f"Error uploading report to CDN: {e}")
        return None


def send_callback(
    project_id: str,
    filepath: str,
    callback_url: str,
    timeout: float = 30.0,
    start_date: Optional[str] = None,
) -> bool:
    """
    Send callback notification after CDN upload.
    
    Args:
        project_id: The project identifier
        filepath: The file path on CDN
        callback_url: URL to POST the callback to
        timeout: Request timeout in seconds
        start_date: Optional start date for the callback payload
        
    Returns:
        True if callback was sent successfully, False otherwise
    """
    if not callback_url:
        print("Warning: No callback URL provided. Skipping callback.")
        return False
    
    if not start_date:
        start_date = datetime.now(timezone.utc).isoformat()
    elif "T" not in start_date:
        start_date = f"{start_date}T00:00:00Z"
    
    payload = {
        "projectId": project_id,
        "date": start_date,
        "filepath": filepath,
    }
    
    print(f"Sending callback to: {callback_url}")
    print(f"Payload: {json.dumps(payload, indent=2)}")
    
    try:
        with httpx.Client(timeout=timeout) as client:
            response = client.post(
                callback_url,
                json=payload,
                headers={"Content-Type": "application/json"},
            )
            response.raise_for_status()
            print(f"Callback sent successfully. Status: {response.status_code}")
            return True
    except httpx.HTTPError as e:
        print(f"Error sending callback: {e}")
        return False
    except Exception as e:
        print(f"Unexpected error sending callback: {e}")
        return False


def run_detection(
    start_date: str,
    end_date: str,
    cdn_url: Optional[str] = None,
    cdn_access_key: Optional[str] = None,
    cdn_secret_key: Optional[str] = None,
    cdn_bucket: Optional[str] = None,
    cdn_enable_ssl: bool = True,
    callback_url: Optional[str] = None,
    timeout: float = 30.0,
) -> Dict[str, Any]:
    """
    Main detection workflow:
    1. Load data from configured source
    2. Process with discrepancy detectors
    3. Upload results to CDN
    4. Send callback notification
    
    Args:
        start_date: Start date in ISO format (e.g., "2025-01-01" or "2025-01-01T00:00:00")
        end_date: End date in ISO format (e.g., "2025-01-31" or "2025-01-31T23:59:59")
        cdn_url: S3-compatible endpoint URL
        cdn_access_key: Access key for CDN
        cdn_secret_key: Secret key for CDN
        cdn_bucket: Bucket name
        cdn_enable_ssl: Whether to use SSL for upload
        callback_url: URL to POST callback notification after upload
        timeout: Request timeout in seconds
        
    Returns:
        The discrepancy report
    """
    print(f"=" * 60)
    print(f"Discrepancy Detection: {{ project_id }}")
    print(f"=" * 60)
    print(f"Start Date: {start_date}")
    print(f"End Date: {end_date}")
    print(f"Data Source: {settings.DATA_SOURCE_TYPE}")
    print(f"-" * 60)
    
    # Step 1: Load data
    print("\n[1/4] Loading data...")
    try:
        df = load_data(start_date, end_date, timeout)
        print(f"Loaded {len(df)} records")
    except Exception as e:
        print(f"Error loading data: {e}")
        raise
    
    # Step 2: Process discrepancies
    print("\n[2/4] Running discrepancy detection...")
    processor = DiscrepancyProcessor()
    report = processor.process(df)
    
    # Add metadata to report
    report["project_id"] = settings.PROJECT_ID
    report["start_date"] = start_date
    report["end_date"] = end_date
    report["generated_at"] = datetime.now(timezone.utc).isoformat()
    
    discrepancy_count = len(report.get("discrepancies", []))
    total_violations = sum(
        d.get("violation_count", 0) for d in report.get("discrepancies", [])
    )

    if discrepancy_count == 0:
        print("No discrepancies found.")
    else:
        print(f"Found {discrepancy_count} rule violations with {total_violations} total issues")

        # Step 3: Upload report to CDN
        print("\n[3/4] Uploading report to CDN...")
        filepath = upload_to_cdn(
            report=report,
            cdn_url=cdn_url,
            access_key=cdn_access_key,
            secret_key=cdn_secret_key,
            bucket_name=cdn_bucket,
            enable_ssl=cdn_enable_ssl,
        )
        
        if filepath:
            report["filepath"] = filepath
            print("\n✓ Report uploaded successfully.")
            
            # Step 4: Send callback notification
            print("\n[4/4] Sending callback notification...")
            callback_success = send_callback(
                project_id=settings.PROJECT_ID,
                filepath=filepath,
                callback_url=callback_url,
                timeout=timeout,
                start_date=start_date
            )
            
            if callback_success:
                print("\n✓ Detection complete. Callback sent successfully.")
            else:
                print("\n⚠ Detection complete. Callback could not be sent.")
        else:
            print("\n⚠ Detection complete. Report could not be uploaded.")
    
    return report


def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Run discrepancy detection for {{ project_id }}"
    )
    parser.add_argument(
        "--start-date",
        required=True,
        help="Start date in ISO format (e.g., 2025-01-01 or 2025-01-01T00:00:00)"
    )
    parser.add_argument(
        "--end-date",
        required=True,
        help="End date in ISO format (e.g., 2025-01-31 or 2025-01-31T23:59:59)"
    )
    parser.add_argument(
        "--cdn-url",
        type=str,
        default=None,
        help="S3-compatible CDN endpoint URL"
    )
    parser.add_argument(
        "--cdn-access-key",
        type=str,
        default=None,
        help="CDN access key"
    )
    parser.add_argument(
        "--cdn-secret-key",
        type=str,
        default=None,
        help="CDN secret key"
    )
    parser.add_argument(
        "--cdn-bucket",
        type=str,
        default=None,
        help="CDN bucket name"
    )
    parser.add_argument(
        "--cdn-no-ssl",
        action="store_true",
        help="Disable SSL for CDN uploads"
    )
    parser.add_argument(
        "--callback-url",
        type=str,
        default=None,
        help="URL to POST callback notification after upload"
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=30.0,
        help="Request timeout in seconds (default: 30.0)"
    )
    parser.add_argument(
        "--output",
        type=str,
        default=None,
        help="Optional file path to save the report as JSON"
    )
    
    args = parser.parse_args()
    
    try:
        # Run detection
        report = run_detection(
            start_date=args.start_date,
            end_date=args.end_date,
            cdn_url=args.cdn_url,
            cdn_access_key=args.cdn_access_key,
            cdn_secret_key=args.cdn_secret_key,
            cdn_bucket=args.cdn_bucket,
            cdn_enable_ssl=not args.cdn_no_ssl,
            callback_url=args.callback_url,
            timeout=args.timeout,
        )
        
        # Optionally save to file
        if args.output:
            with open(args.output, "w") as f:
                json.dump(report, f, indent=2, default=str)
            print(f"\nReport saved to: {args.output}")
        
        # Exit with error code if discrepancies found
        if report.get("discrepancies"):
            sys.exit(1)
        sys.exit(0)
        
    except Exception as e:
        print(f"\nFatal error: {e}")
        sys.exit(2)


if __name__ == "__main__":
    main()